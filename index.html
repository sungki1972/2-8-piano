<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>합창 음잡이</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  touch-action: none;
  user-select: none;
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: #1a1a2e;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}

/* ── Tuner ── */
#tuner {
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 160px;
  background: linear-gradient(135deg, #0f0f23, #1a1a3e);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 10;
  border-bottom: 2px solid #333;
}

#tuner-note {
  font-size: 52px;
  font-weight: 900;
  color: #fff;
  line-height: 1;
  min-width: 80px;
  text-align: center;
}

#tuner-freq {
  font-size: 13px;
  color: #888;
  margin-top: 2px;
}

#tuner-meter {
  width: 80%;
  max-width: 350px;
  height: 28px;
  margin-top: 8px;
  position: relative;
  display: flex;
  align-items: center;
}

#meter-bar {
  width: 100%;
  height: 6px;
  background: #333;
  border-radius: 3px;
  position: relative;
}

#meter-bar::after {
  content: '';
  position: absolute;
  left: 50%;
  top: -8px;
  width: 2px;
  height: 22px;
  background: #555;
  transform: translateX(-50%);
}

#meter-needle {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 14px;
  height: 14px;
  background: #f44;
  border-radius: 50%;
  transform: translate(-50%, -50%);
  transition: left 0.1s ease-out;
  box-shadow: 0 0 8px rgba(255,68,68,0.5);
}

#meter-needle.in-tune {
  background: #4f4;
  box-shadow: 0 0 12px rgba(68,255,68,0.6);
}

#meter-labels {
  display: flex;
  justify-content: space-between;
  width: 100%;
  position: absolute;
  bottom: -2px;
  font-size: 10px;
  color: #666;
}

#mic-btn {
  position: absolute;
  top: 10px;
  right: 12px;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  border: 2px solid #555;
  background: #222;
  color: #888;
  font-size: 18px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 11;
}

#mic-btn.on {
  border-color: #f44;
  background: #411;
  color: #f66;
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0%, 100% { box-shadow: 0 0 0 0 rgba(255,68,68,0.4); }
  50% { box-shadow: 0 0 0 6px rgba(255,68,68,0); }
}

/* ── Piano ── */
#piano {
  position: absolute;
  top: 160px;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
}

.white-key {
  flex: 1;
  height: 100%;
  background: linear-gradient(180deg, #fafafa 0%, #f0f0f0 60%, #e0e0e0 100%);
  border: 1px solid #bbb;
  border-top: none;
  border-radius: 0 0 10px 10px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-end;
  padding-bottom: clamp(12px, 3vh, 30px);
  cursor: pointer;
  position: relative;
  z-index: 1;
  transition: background 0.05s;
}

.white-key .note-label {
  font-size: clamp(14px, 3.5vw, 24px);
  font-weight: 800;
  color: #999;
  pointer-events: none;
}

.white-key.active {
  background: linear-gradient(180deg, #dde8ff 0%, #c8d8f0 60%, #b0c4e8 100%);
}

.white-key.active .note-label {
  color: #4a70c0;
}

.black-key {
  position: absolute;
  top: 160px;
  width: calc(100% / 8 * 0.65);
  height: calc((100% - 160px) * 0.58);
  background: linear-gradient(180deg, #444 0%, #222 40%, #111 100%);
  border-radius: 0 0 8px 8px;
  z-index: 2;
  cursor: pointer;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  padding-bottom: clamp(8px, 2vh, 18px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.5), inset 0 -2px 4px rgba(255,255,255,0.05);
  transition: background 0.05s;
}

.black-key .note-label {
  font-size: clamp(9px, 2vw, 15px);
  font-weight: 700;
  color: #777;
  pointer-events: none;
}

.black-key.active {
  background: linear-gradient(180deg, #556 0%, #334 40%, #223 100%);
  box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 -1px 2px rgba(255,255,255,0.05);
  padding-top: 2px;
}

.black-key.active .note-label {
  color: #aac;
}

/* Highlighted key when tuner detects note */
.white-key.detected {
  background: linear-gradient(180deg, #e8ffe8 0%, #c0f0c0 60%, #a0e0a0 100%);
}
.white-key.detected .note-label { color: #2a8a2a; }
.black-key.detected {
  background: linear-gradient(180deg, #3a5a3a 0%, #2a4a2a 40%, #1a3a1a 100%);
}
.black-key.detected .note-label { color: #8f8; }
</style>
</head>
<body>

<div id="tuner">
  <div id="tuner-note">--</div>
  <div id="tuner-freq">마이크를 켜서 음을 감지하세요</div>
  <div id="tuner-meter">
    <div id="meter-bar"></div>
    <div id="meter-needle" style="left:50%"></div>
    <div id="meter-labels"><span>-50</span><span>0</span><span>+50</span></div>
  </div>
  <button id="mic-btn" onclick="toggleMic()">&#x1f3a4;</button>
</div>

<div id="piano"></div>

<script>
// ── Notes ──
const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];

const notes = [
  { name: 'C',  freq: 261.63, type: 'white', sample: 'C4'  },
  { name: 'C#', freq: 277.18, type: 'black', sample: 'Db4' },
  { name: 'D',  freq: 293.66, type: 'white', sample: 'D4'  },
  { name: 'D#', freq: 311.13, type: 'black', sample: 'Eb4' },
  { name: 'E',  freq: 329.63, type: 'white', sample: 'E4'  },
  { name: 'F',  freq: 349.23, type: 'white', sample: 'F4'  },
  { name: 'F#', freq: 369.99, type: 'black', sample: 'Gb4' },
  { name: 'G',  freq: 392.00, type: 'white', sample: 'G4'  },
  { name: 'G#', freq: 415.30, type: 'black', sample: 'Ab4' },
  { name: 'A',  freq: 440.00, type: 'white', sample: 'A4'  },
  { name: 'A#', freq: 466.16, type: 'black', sample: 'Bb4' },
  { name: 'B',  freq: 493.88, type: 'white', sample: 'B4'  },
  { name: 'C2', freq: 523.25, type: 'white', sample: 'C5'  },
];

// ── Audio context & piano samples ──
let audioCtx = null;
const activeNotes = {};
const sampleBuffers = {};
let samplesLoaded = false;

function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

const SAMPLE_BASE = 'https://gleitz.github.io/midi-js-soundfonts/MusyngKite/acoustic_grand_piano-mp3/';

async function loadPianoSamples() {
  const ctx = getAudioCtx();
  await Promise.all(notes.map(async note => {
    try {
      const resp = await fetch(SAMPLE_BASE + note.sample + '.mp3');
      const buf = await resp.arrayBuffer();
      sampleBuffers[note.name] = await ctx.decodeAudioData(buf);
    } catch(e) { console.warn('Sample load failed:', note.sample); }
  }));
  samplesLoaded = true;
}

function startNote(note) {
  if (activeNotes[note.name]) return;
  const ctx = getAudioCtx();
  const buffer = sampleBuffers[note.name];

  if (buffer) {
    const source = ctx.createBufferSource();
    source.buffer = buffer;
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(1.0, ctx.currentTime);
    source.connect(gain);
    gain.connect(ctx.destination);
    source.start();
    activeNotes[note.name] = { source, gain, ctx };
  } else {
    // Synthesis fallback
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(note.freq, ctx.currentTime);
    gain.gain.setValueAtTime(0, ctx.currentTime);
    gain.gain.linearRampToValueAtTime(0.4, ctx.currentTime + 0.02);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    activeNotes[note.name] = { source: osc, gain, ctx, synth: true };
  }
}

function stopNote(note) {
  const data = activeNotes[note.name];
  if (!data) return;
  const { source, gain, ctx } = data;
  gain.gain.cancelScheduledValues(ctx.currentTime);
  gain.gain.setValueAtTime(gain.gain.value, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);
  setTimeout(() => { try { source.stop(); } catch(e) {} }, 500);
  delete activeNotes[note.name];
}

// ── Tuner (pitch detection) ──
let micStream = null;
let micAnalyser = null;
let micSource = null;
let tunerRunning = false;
let tunerRAF = null;
let lastDetectedNote = null;

function toggleMic() {
  if (tunerRunning) stopTuner();
  else startTuner();
}

async function startTuner() {
  try {
    const ctx = getAudioCtx();
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    micSource = ctx.createMediaStreamSource(micStream);
    micAnalyser = ctx.createAnalyser();
    micAnalyser.fftSize = 4096;
    micSource.connect(micAnalyser);
    tunerRunning = true;
    document.getElementById('mic-btn').classList.add('on');
    detectPitch();
  } catch(e) {
    alert('마이크 접근이 거부되었습니다.');
  }
}

function stopTuner() {
  tunerRunning = false;
  if (tunerRAF) cancelAnimationFrame(tunerRAF);
  if (micStream) micStream.getTracks().forEach(t => t.stop());
  micStream = null;
  document.getElementById('mic-btn').classList.remove('on');
  document.getElementById('tuner-note').textContent = '--';
  document.getElementById('tuner-freq').textContent = '마이크를 켜서 음을 감지하세요';
  document.getElementById('meter-needle').style.left = '50%';
  document.getElementById('meter-needle').classList.remove('in-tune');
  clearDetectedHighlight();
}

function detectPitch() {
  if (!tunerRunning) return;
  const buf = new Float32Array(micAnalyser.fftSize);
  micAnalyser.getFloatTimeDomainData(buf);

  const freq = autoCorrelate(buf, audioCtx.sampleRate);

  if (freq > 0) {
    const { note, cents, octave } = freqToNote(freq);
    const displayName = note + octave;

    document.getElementById('tuner-note').textContent = displayName;
    document.getElementById('tuner-freq').textContent = freq.toFixed(1) + ' Hz';

    // Meter: cents range -50 to +50 mapped to 0% - 100%
    const pct = Math.max(0, Math.min(100, 50 + cents));
    const needle = document.getElementById('meter-needle');
    needle.style.left = pct + '%';
    needle.classList.toggle('in-tune', Math.abs(cents) < 5);

    highlightDetected(note);
  }

  tunerRAF = requestAnimationFrame(detectPitch);
}

// Autocorrelation pitch detection
function autoCorrelate(buf, sampleRate) {
  // Check if there's enough signal
  let rms = 0;
  for (let i = 0; i < buf.length; i++) rms += buf[i] * buf[i];
  rms = Math.sqrt(rms / buf.length);
  if (rms < 0.01) return -1; // too quiet

  // Trim silence from edges
  let start = 0, end = buf.length - 1;
  const threshold = 0.2;
  while (start < buf.length / 2 && Math.abs(buf[start]) < threshold) start++;
  while (end > buf.length / 2 && Math.abs(buf[end]) < threshold) end--;
  const trimmed = buf.slice(start, end + 1);

  // Autocorrelation
  const len = trimmed.length;
  const corr = new Float32Array(len);
  for (let lag = 0; lag < len; lag++) {
    let sum = 0;
    for (let i = 0; i < len - lag; i++) {
      sum += trimmed[i] * trimmed[i + lag];
    }
    corr[lag] = sum;
  }

  // Find first dip then first peak
  let d = 0;
  while (d < len && corr[d] > corr[d + 1]) d++;

  let maxVal = -1, maxPos = -1;
  for (let i = d; i < len; i++) {
    if (corr[i] > maxVal) {
      maxVal = corr[i];
      maxPos = i;
    }
  }

  if (maxPos <= 0) return -1;

  // Parabolic interpolation for sub-sample accuracy
  const y1 = corr[maxPos - 1] || 0;
  const y2 = corr[maxPos];
  const y3 = corr[maxPos + 1] || 0;
  const shift = (y3 - y1) / (2 * (2 * y2 - y1 - y3));
  const refinedPos = maxPos + (isFinite(shift) ? shift : 0);

  return sampleRate / refinedPos;
}

function freqToNote(freq) {
  const semitones = 12 * Math.log2(freq / 440);
  const rounded = Math.round(semitones);
  const cents = (semitones - rounded) * 100;
  const noteIndex = ((rounded % 12) + 12) % 12;
  const note = NOTE_NAMES[(noteIndex + 9) % 12]; // A=0 -> remap
  const octave = Math.floor((rounded + 9) / 12) + 4; // A4 = 440
  return { note, cents, octave };
}

function highlightDetected(noteName) {
  if (lastDetectedNote === noteName) return;
  clearDetectedHighlight();
  lastDetectedNote = noteName;
  // Highlight matching piano keys
  document.querySelectorAll(`[data-note="${noteName}"], [data-note="${noteName}2"]`).forEach(el => {
    el.classList.add('detected');
  });
}

function clearDetectedHighlight() {
  document.querySelectorAll('.detected').forEach(el => el.classList.remove('detected'));
  lastDetectedNote = null;
}

// ── Build piano UI ──
const piano = document.getElementById('piano');

notes.filter(n => n.type === 'white').forEach(note => {
  const key = document.createElement('div');
  key.className = 'white-key';
  key.dataset.note = note.name;
  const label = document.createElement('span');
  label.className = 'note-label';
  label.textContent = note.name.replace('2', '');
  key.appendChild(label);
  piano.appendChild(key);
});

const blackKeyPositions = [
  { note: 'C#', afterWhite: 0 },
  { note: 'D#', afterWhite: 1 },
  { note: 'F#', afterWhite: 3 },
  { note: 'G#', afterWhite: 4 },
  { note: 'A#', afterWhite: 5 },
];
const whiteKeyWidth = 100 / 8;

blackKeyPositions.forEach(pos => {
  const note = notes.find(n => n.name === pos.note);
  const key = document.createElement('div');
  key.className = 'black-key';
  key.dataset.note = note.name;
  const label = document.createElement('span');
  label.className = 'note-label';
  label.textContent = note.name;
  key.appendChild(label);
  key.style.left = ((pos.afterWhite + 1) * whiteKeyWidth - whiteKeyWidth * 0.325) + '%';
  piano.appendChild(key);
});

// ── Event handlers ──
function handleStart(el) {
  const keyEl = el.closest('.white-key, .black-key');
  if (!keyEl) return;
  const note = notes.find(n => n.name === keyEl.dataset.note);
  if (note) { keyEl.classList.add('active'); startNote(note); }
}

function handleEnd(el) {
  const keyEl = el.closest('.white-key, .black-key');
  if (!keyEl) return;
  const note = notes.find(n => n.name === keyEl.dataset.note);
  if (note) { keyEl.classList.remove('active'); stopNote(note); }
}

piano.addEventListener('mousedown', e => {
  handleStart(e.target);
  const onMove = ev => {
    const el = document.elementFromPoint(ev.clientX, ev.clientY);
    if (el) {
      document.querySelectorAll('#piano .active').forEach(k => {
        if (k !== el.closest('.white-key, .black-key')) handleEnd(k);
      });
      handleStart(el);
    }
  };
  const onUp = () => {
    document.querySelectorAll('#piano .active').forEach(k => handleEnd(k));
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
  };
  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
});

const activeTouches = {};

piano.addEventListener('touchstart', e => {
  e.preventDefault();
  for (const touch of e.changedTouches) {
    const el = document.elementFromPoint(touch.clientX, touch.clientY);
    if (el) {
      const keyEl = el.closest('.white-key, .black-key');
      if (keyEl) { activeTouches[touch.identifier] = keyEl.dataset.note; handleStart(el); }
    }
  }
}, { passive: false });

piano.addEventListener('touchmove', e => {
  e.preventDefault();
  for (const touch of e.changedTouches) {
    const el = document.elementFromPoint(touch.clientX, touch.clientY);
    if (el) {
      const keyEl = el.closest('.white-key, .black-key');
      const prev = activeTouches[touch.identifier];
      if (keyEl && keyEl.dataset.note !== prev) {
        if (prev) { const pk = document.querySelector(`[data-note="${prev}"]`); if (pk) handleEnd(pk); }
        activeTouches[touch.identifier] = keyEl.dataset.note;
        handleStart(el);
      }
    }
  }
}, { passive: false });

piano.addEventListener('touchend', e => {
  e.preventDefault();
  for (const touch of e.changedTouches) {
    const n = activeTouches[touch.identifier];
    if (n) { const k = document.querySelector(`[data-note="${n}"]`); if (k) handleEnd(k); delete activeTouches[touch.identifier]; }
  }
}, { passive: false });

piano.addEventListener('touchcancel', e => {
  for (const touch of e.changedTouches) {
    const n = activeTouches[touch.identifier];
    if (n) { const k = document.querySelector(`[data-note="${n}"]`); if (k) handleEnd(k); delete activeTouches[touch.identifier]; }
  }
});

const keyMap = {
  'a':'C','w':'C#','s':'D','e':'D#','d':'E',
  'f':'F','t':'F#','g':'G','y':'G#','h':'A',
  'u':'A#','j':'B','k':'C2'
};

document.addEventListener('keydown', e => {
  if (e.repeat) return;
  const n = keyMap[e.key.toLowerCase()];
  if (n) { const note = notes.find(x => x.name === n); const k = document.querySelector(`[data-note="${n}"]`); if (note && k) { k.classList.add('active'); startNote(note); } }
});

document.addEventListener('keyup', e => {
  const n = keyMap[e.key.toLowerCase()];
  if (n) { const note = notes.find(x => x.name === n); const k = document.querySelector(`[data-note="${n}"]`); if (note && k) { k.classList.remove('active'); stopNote(note); } }
});

// Load samples on first interaction
function initSamples() { if (!samplesLoaded) loadPianoSamples(); }
document.addEventListener('click', initSamples, { once: true });
document.addEventListener('touchstart', initSamples, { once: true });
</script>
</body>
</html>
