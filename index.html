<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>합창 음잡이</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  touch-action: none;
  user-select: none;
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: #1a1a2e;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}

/* ── Wrapper for rotation ── */
#wrapper {
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}

#wrapper.rotated {
  width: 100vh;
  height: 100vw;
  transform-origin: top left;
  transform: rotate(90deg) translate(0, -100%);
}

/* ── Top bar (tuner + buttons) ── */
#top-bar {
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 130px;
  background: linear-gradient(135deg, #0f0f23, #1a1a3e);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
  border-bottom: 2px solid #333;
  padding: 0 50px;
}

.rotated #top-bar {
  height: 90px;
  padding: 0 46px;
}

/* Tuner display */
#tuner-info {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex: 1;
}

#tuner-note {
  font-size: 48px;
  font-weight: 900;
  color: #fff;
  line-height: 1;
}

.rotated #tuner-note {
  font-size: 34px;
}

#tuner-freq {
  font-size: 12px;
  color: #888;
  margin-top: 2px;
}

#tuner-meter {
  width: 70%;
  max-width: 300px;
  height: 24px;
  margin-top: 6px;
  position: relative;
  display: flex;
  align-items: center;
}

.rotated #tuner-meter {
  margin-top: 3px;
  height: 18px;
}

#meter-bar {
  width: 100%;
  height: 5px;
  background: #333;
  border-radius: 3px;
  position: relative;
}

#meter-bar::after {
  content: '';
  position: absolute;
  left: 50%;
  top: -7px;
  width: 2px;
  height: 19px;
  background: #555;
  transform: translateX(-50%);
}

#meter-needle {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 12px;
  height: 12px;
  background: #f44;
  border-radius: 50%;
  transform: translate(-50%, -50%);
  transition: left 0.1s ease-out;
  box-shadow: 0 0 8px rgba(255,68,68,0.5);
}

#meter-needle.in-tune {
  background: #4f4;
  box-shadow: 0 0 12px rgba(68,255,68,0.6);
}

#meter-labels {
  display: flex;
  justify-content: space-between;
  width: 100%;
  position: absolute;
  bottom: -2px;
  font-size: 9px;
  color: #555;
}

/* Buttons */
.top-btn {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: 38px;
  height: 38px;
  border-radius: 50%;
  border: 2px solid #555;
  background: #222;
  color: #888;
  font-size: 16px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 11;
}

.rotated .top-btn {
  width: 32px;
  height: 32px;
  font-size: 14px;
}

#mic-btn { right: 8px; }
#rotate-btn { left: 8px; }
#vol-btn { right: 52px; font-size: 13px; font-weight: 900; }

#vol-btn.on {
  border-color: #f90;
  background: #432;
  color: #fb0;
}

#mic-btn.on {
  border-color: #f44;
  background: #411;
  color: #f66;
  animation: pulse 1.5s infinite;
}

#rotate-btn.on {
  border-color: #4a90d9;
  background: #1a2a44;
  color: #6ab0ff;
}

@keyframes pulse {
  0%, 100% { box-shadow: 0 0 0 0 rgba(255,68,68,0.4); }
  50% { box-shadow: 0 0 0 6px rgba(255,68,68,0); }
}

/* ── Piano ── */
#piano {
  position: absolute;
  top: 130px;
  left: 0; right: 0; bottom: 0;
  display: flex;
}

.rotated #piano {
  top: 90px;
}

.white-key {
  flex: 1;
  height: 100%;
  background: linear-gradient(180deg, #fafafa 0%, #f0f0f0 60%, #e0e0e0 100%);
  border: 1px solid #bbb;
  border-top: none;
  border-radius: 0 0 10px 10px;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  padding-bottom: clamp(10px, 3vh, 30px);
  cursor: pointer;
  position: relative;
  z-index: 1;
  transition: background 0.06s;
}

.white-key .note-label {
  font-size: clamp(13px, 3vw, 22px);
  font-weight: 800;
  color: #999;
  pointer-events: none;
}

.rotated .white-key .note-label {
  font-size: clamp(13px, 3vh, 22px);
}

.white-key.active {
  background: linear-gradient(180deg, #dde8ff 0%, #c8d8f0 60%, #b0c4e8 100%);
}
.white-key.active .note-label { color: #4a70c0; }

.black-key {
  position: absolute;
  top: 130px;
  width: calc(100% / 10 * 0.62);
  height: calc((100% - 130px) * 0.57);
  background: linear-gradient(180deg, #444 0%, #222 40%, #111 100%);
  border-radius: 0 0 8px 8px;
  z-index: 2;
  cursor: pointer;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  padding-bottom: clamp(6px, 2vh, 16px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.5), inset 0 -2px 4px rgba(255,255,255,0.05);
  transition: background 0.06s;
}

.rotated .black-key {
  top: 90px;
  height: calc((100% - 90px) * 0.57);
}

.black-key .note-label {
  font-size: clamp(9px, 1.8vw, 14px);
  font-weight: 700;
  color: #777;
  pointer-events: none;
}

.rotated .black-key .note-label {
  font-size: clamp(9px, 1.8vh, 14px);
}

.black-key.active {
  background: linear-gradient(180deg, #556 0%, #334 40%, #223 100%);
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
.black-key.active .note-label { color: #aac; }

/* Tuner detected highlight */
.white-key.detected {
  background: linear-gradient(180deg, #e8ffe8 0%, #c0f0c0 60%, #a0e0a0 100%);
}
.white-key.detected .note-label { color: #2a8a2a; }
.black-key.detected {
  background: linear-gradient(180deg, #3a5a3a 0%, #2a4a2a 40%, #1a3a1a 100%);
}
.black-key.detected .note-label { color: #8f8; }
</style>
</head>
<body>

<div id="wrapper">
  <div id="top-bar">
    <button class="top-btn" id="rotate-btn" onclick="toggleRotate()">&#x21BB;</button>
    <div id="tuner-info">
      <div id="tuner-note">--</div>
      <div id="tuner-freq">마이크를 켜서 음을 감지하세요</div>
      <div id="tuner-meter">
        <div id="meter-bar"></div>
        <div id="meter-needle" style="left:50%"></div>
        <div id="meter-labels"><span>-50</span><span>0</span><span>+50</span></div>
      </div>
    </div>
    <button class="top-btn" id="vol-btn" onclick="toggleBoost()">x1</button>
    <button class="top-btn" id="mic-btn" onclick="toggleMic()">&#x1f3a4;</button>
  </div>
  <div id="piano"></div>
</div>

<script>
// ── Notes ──
const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];

const notes = [
  { name: 'C',   freq: 261.63, type: 'white', sample: 'C4'  },
  { name: 'C#',  freq: 277.18, type: 'black', sample: 'Db4' },
  { name: 'D',   freq: 293.66, type: 'white', sample: 'D4'  },
  { name: 'D#',  freq: 311.13, type: 'black', sample: 'Eb4' },
  { name: 'E',   freq: 329.63, type: 'white', sample: 'E4'  },
  { name: 'F',   freq: 349.23, type: 'white', sample: 'F4'  },
  { name: 'F#',  freq: 369.99, type: 'black', sample: 'Gb4' },
  { name: 'G',   freq: 392.00, type: 'white', sample: 'G4'  },
  { name: 'G#',  freq: 415.30, type: 'black', sample: 'Ab4' },
  { name: 'A',   freq: 440.00, type: 'white', sample: 'A4'  },
  { name: 'A#',  freq: 466.16, type: 'black', sample: 'Bb4' },
  { name: 'B',   freq: 493.88, type: 'white', sample: 'B4'  },
  { name: 'C2',  freq: 523.25, type: 'white', sample: 'C5'  },
  { name: 'C#2', freq: 554.37, type: 'black', sample: 'Db5' },
  { name: 'D2',  freq: 587.33, type: 'white', sample: 'D5'  },
  { name: 'D#2', freq: 622.25, type: 'black', sample: 'Eb5' },
  { name: 'E2',  freq: 659.26, type: 'white', sample: 'E5'  },
];

// ── Audio ──
let audioCtx = null;
let masterGain = null;
let compressor = null;
let boostOn = false;
const activeNotes = {};
const sampleBuffers = {};
let samplesLoaded = false;

function getAudioCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    // Master gain → Compressor → Destination
    compressor = audioCtx.createDynamicsCompressor();
    compressor.threshold.setValueAtTime(-24, audioCtx.currentTime);
    compressor.knee.setValueAtTime(12, audioCtx.currentTime);
    compressor.ratio.setValueAtTime(4, audioCtx.currentTime);
    compressor.attack.setValueAtTime(0.003, audioCtx.currentTime);
    compressor.release.setValueAtTime(0.1, audioCtx.currentTime);
    masterGain = audioCtx.createGain();
    masterGain.gain.setValueAtTime(1.0, audioCtx.currentTime);
    masterGain.connect(compressor);
    compressor.connect(audioCtx.destination);
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

function toggleBoost() {
  boostOn = !boostOn;
  const ctx = getAudioCtx();
  // x1 = normal, x2 = boosted
  masterGain.gain.setValueAtTime(boostOn ? 2.5 : 1.0, ctx.currentTime);
  document.getElementById('vol-btn').textContent = boostOn ? 'x2' : 'x1';
  document.getElementById('vol-btn').classList.toggle('on', boostOn);
}

const SAMPLE_BASE = 'https://gleitz.github.io/midi-js-soundfonts/MusyngKite/acoustic_grand_piano-mp3/';

async function loadPianoSamples() {
  const ctx = getAudioCtx();
  await Promise.all(notes.map(async note => {
    try {
      const resp = await fetch(SAMPLE_BASE + note.sample + '.mp3');
      const buf = await resp.arrayBuffer();
      sampleBuffers[note.name] = await ctx.decodeAudioData(buf);
    } catch(e) { console.warn('Sample load failed:', note.sample); }
  }));
  samplesLoaded = true;
}

function startNote(note) {
  if (activeNotes[note.name]) return;
  const ctx = getAudioCtx();
  const buffer = sampleBuffers[note.name];
  if (buffer) {
    const source = ctx.createBufferSource();
    source.buffer = buffer;
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(1.0, ctx.currentTime);
    source.connect(gain);
    gain.connect(masterGain);
    source.start();
    activeNotes[note.name] = { source, gain, ctx };
  } else {
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(note.freq, ctx.currentTime);
    gain.gain.setValueAtTime(0, ctx.currentTime);
    gain.gain.linearRampToValueAtTime(0.4, ctx.currentTime + 0.02);
    osc.connect(gain);
    gain.connect(masterGain);
    osc.start();
    activeNotes[note.name] = { source: osc, gain, ctx };
  }
}

function stopNote(note) {
  const data = activeNotes[note.name];
  if (!data) return;
  const { source, gain, ctx } = data;
  gain.gain.cancelScheduledValues(ctx.currentTime);
  gain.gain.setValueAtTime(gain.gain.value, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);
  setTimeout(() => { try { source.stop(); } catch(e) {} }, 500);
  delete activeNotes[note.name];
}

// ── Rotation toggle ──
let isRotated = false;

function toggleRotate() {
  isRotated = !isRotated;
  document.getElementById('wrapper').classList.toggle('rotated', isRotated);
  document.getElementById('rotate-btn').classList.toggle('on', isRotated);
}

// ── Tuner ──
let micStream = null;
let micAnalyser = null;
let tunerRunning = false;
let tunerRAF = null;
let lastDetectedNote = null;

function toggleMic() {
  if (tunerRunning) stopTuner();
  else startTuner();
}

async function startTuner() {
  try {
    const ctx = getAudioCtx();
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const micSource = ctx.createMediaStreamSource(micStream);
    micAnalyser = ctx.createAnalyser();
    micAnalyser.fftSize = 4096;
    micSource.connect(micAnalyser);
    tunerRunning = true;
    document.getElementById('mic-btn').classList.add('on');
    detectPitch();
  } catch(e) {
    alert('마이크 접근이 거부되었습니다.');
  }
}

function stopTuner() {
  tunerRunning = false;
  if (tunerRAF) cancelAnimationFrame(tunerRAF);
  if (micStream) micStream.getTracks().forEach(t => t.stop());
  micStream = null;
  document.getElementById('mic-btn').classList.remove('on');
  document.getElementById('tuner-note').textContent = '--';
  document.getElementById('tuner-freq').textContent = '마이크를 켜서 음을 감지하세요';
  document.getElementById('meter-needle').style.left = '50%';
  document.getElementById('meter-needle').classList.remove('in-tune');
  clearDetectedHighlight();
}

function detectPitch() {
  if (!tunerRunning) return;
  const buf = new Float32Array(micAnalyser.fftSize);
  micAnalyser.getFloatTimeDomainData(buf);
  const freq = autoCorrelate(buf, audioCtx.sampleRate);
  if (freq > 0) {
    const { note, cents, octave } = freqToNote(freq);
    document.getElementById('tuner-note').textContent = note + octave;
    document.getElementById('tuner-freq').textContent = freq.toFixed(1) + ' Hz';
    const pct = Math.max(0, Math.min(100, 50 + cents));
    const needle = document.getElementById('meter-needle');
    needle.style.left = pct + '%';
    needle.classList.toggle('in-tune', Math.abs(cents) < 5);
    highlightDetected(note);
  }
  tunerRAF = requestAnimationFrame(detectPitch);
}

function autoCorrelate(buf, sampleRate) {
  let rms = 0;
  for (let i = 0; i < buf.length; i++) rms += buf[i] * buf[i];
  rms = Math.sqrt(rms / buf.length);
  if (rms < 0.01) return -1;

  let start = 0, end = buf.length - 1;
  const threshold = 0.2;
  while (start < buf.length / 2 && Math.abs(buf[start]) < threshold) start++;
  while (end > buf.length / 2 && Math.abs(buf[end]) < threshold) end--;
  const trimmed = buf.slice(start, end + 1);
  const len = trimmed.length;
  const corr = new Float32Array(len);
  for (let lag = 0; lag < len; lag++) {
    let sum = 0;
    for (let i = 0; i < len - lag; i++) sum += trimmed[i] * trimmed[i + lag];
    corr[lag] = sum;
  }
  let d = 0;
  while (d < len && corr[d] > corr[d + 1]) d++;
  let maxVal = -1, maxPos = -1;
  for (let i = d; i < len; i++) {
    if (corr[i] > maxVal) { maxVal = corr[i]; maxPos = i; }
  }
  if (maxPos <= 0) return -1;
  const y1 = corr[maxPos - 1] || 0;
  const y2 = corr[maxPos];
  const y3 = corr[maxPos + 1] || 0;
  const shift = (y3 - y1) / (2 * (2 * y2 - y1 - y3));
  return sampleRate / (maxPos + (isFinite(shift) ? shift : 0));
}

function freqToNote(freq) {
  const semitones = 12 * Math.log2(freq / 440);
  const rounded = Math.round(semitones);
  const cents = (semitones - rounded) * 100;
  const noteIndex = ((rounded % 12) + 12) % 12;
  const note = NOTE_NAMES[(noteIndex + 9) % 12];
  const octave = Math.floor((rounded + 9) / 12) + 4;
  return { note, cents, octave };
}

function highlightDetected(noteName) {
  if (lastDetectedNote === noteName) return;
  clearDetectedHighlight();
  lastDetectedNote = noteName;
  document.querySelectorAll('.white-key, .black-key').forEach(el => {
    if (el.dataset.note.replace(/2$/, '') === noteName) el.classList.add('detected');
  });
}

function clearDetectedHighlight() {
  document.querySelectorAll('.detected').forEach(el => el.classList.remove('detected'));
  lastDetectedNote = null;
}

// ── Build piano ──
const piano = document.getElementById('piano');

notes.filter(n => n.type === 'white').forEach(note => {
  const key = document.createElement('div');
  key.className = 'white-key';
  key.dataset.note = note.name;
  const label = document.createElement('span');
  label.className = 'note-label';
  label.textContent = note.name.replace(/2$/, '');
  key.appendChild(label);
  piano.appendChild(key);
});

const blackKeyPositions = [
  { note: 'C#',  afterWhite: 0 },
  { note: 'D#',  afterWhite: 1 },
  { note: 'F#',  afterWhite: 3 },
  { note: 'G#',  afterWhite: 4 },
  { note: 'A#',  afterWhite: 5 },
  { note: 'C#2', afterWhite: 7 },
  { note: 'D#2', afterWhite: 8 },
];
const whiteKeyWidth = 100 / 10;

blackKeyPositions.forEach(pos => {
  const note = notes.find(n => n.name === pos.note);
  const key = document.createElement('div');
  key.className = 'black-key';
  key.dataset.note = note.name;
  const label = document.createElement('span');
  label.className = 'note-label';
  label.textContent = note.name;
  key.appendChild(label);
  key.style.left = ((pos.afterWhite + 1) * whiteKeyWidth - whiteKeyWidth * 0.31) + '%';
  piano.appendChild(key);
});

// ── Events ──
function handleStart(el) {
  const keyEl = el.closest('.white-key, .black-key');
  if (!keyEl) return;
  const note = notes.find(n => n.name === keyEl.dataset.note);
  if (note) { keyEl.classList.add('active'); startNote(note); }
}

function handleEnd(el) {
  const keyEl = el.closest('.white-key, .black-key');
  if (!keyEl) return;
  const note = notes.find(n => n.name === keyEl.dataset.note);
  if (note) { keyEl.classList.remove('active'); stopNote(note); }
}

piano.addEventListener('mousedown', e => {
  handleStart(e.target);
  const onMove = ev => {
    const el = document.elementFromPoint(ev.clientX, ev.clientY);
    if (el) {
      document.querySelectorAll('#piano .active').forEach(k => {
        if (k !== el.closest('.white-key, .black-key')) handleEnd(k);
      });
      handleStart(el);
    }
  };
  const onUp = () => {
    document.querySelectorAll('#piano .active').forEach(k => handleEnd(k));
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
  };
  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
});

const activeTouches = {};

piano.addEventListener('touchstart', e => {
  e.preventDefault();
  for (const touch of e.changedTouches) {
    const el = document.elementFromPoint(touch.clientX, touch.clientY);
    if (el) {
      const keyEl = el.closest('.white-key, .black-key');
      if (keyEl) { activeTouches[touch.identifier] = keyEl.dataset.note; handleStart(el); }
    }
  }
}, { passive: false });

piano.addEventListener('touchmove', e => {
  e.preventDefault();
  for (const touch of e.changedTouches) {
    const el = document.elementFromPoint(touch.clientX, touch.clientY);
    if (el) {
      const keyEl = el.closest('.white-key, .black-key');
      const prev = activeTouches[touch.identifier];
      if (keyEl && keyEl.dataset.note !== prev) {
        if (prev) { const pk = document.querySelector(`[data-note="${prev}"]`); if (pk) handleEnd(pk); }
        activeTouches[touch.identifier] = keyEl.dataset.note;
        handleStart(el);
      }
    }
  }
}, { passive: false });

piano.addEventListener('touchend', e => {
  e.preventDefault();
  for (const touch of e.changedTouches) {
    const n = activeTouches[touch.identifier];
    if (n) { const k = document.querySelector(`[data-note="${n}"]`); if (k) handleEnd(k); delete activeTouches[touch.identifier]; }
  }
}, { passive: false });

piano.addEventListener('touchcancel', e => {
  for (const touch of e.changedTouches) {
    const n = activeTouches[touch.identifier];
    if (n) { const k = document.querySelector(`[data-note="${n}"]`); if (k) handleEnd(k); delete activeTouches[touch.identifier]; }
  }
});

const keyMap = {
  'a':'C','w':'C#','s':'D','e':'D#','d':'E',
  'f':'F','t':'F#','g':'G','y':'G#','h':'A',
  'u':'A#','j':'B','k':'C2','o':'C#2','l':'D2',
  'p':'D#2',';':'E2'
};

document.addEventListener('keydown', e => {
  if (e.repeat) return;
  const n = keyMap[e.key.toLowerCase()];
  if (n) { const note = notes.find(x => x.name === n); const k = document.querySelector(`[data-note="${n}"]`); if (note && k) { k.classList.add('active'); startNote(note); } }
});

document.addEventListener('keyup', e => {
  const n = keyMap[e.key.toLowerCase()];
  if (n) { const note = notes.find(x => x.name === n); const k = document.querySelector(`[data-note="${n}"]`); if (note && k) { k.classList.remove('active'); stopNote(note); } }
});

function initSamples() { if (!samplesLoaded) loadPianoSamples(); }
document.addEventListener('click', initSamples, { once: true });
document.addEventListener('touchstart', initSamples, { once: true });
</script>
</body>
</html>
